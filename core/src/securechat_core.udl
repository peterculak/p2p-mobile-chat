// UniFFI interface definition
namespace securechat_core {
    // Identity management
    Identity generate_identity();
    string get_public_key_hex([ByRef] Identity identity);
    string get_public_key_fingerprint([ByRef] Identity identity);
    
    // Key exchange
    SharedSecret perform_key_exchange([ByRef] Identity my_identity, string their_public_key_hex);
    
    // P2P Network Manager (singleton for iOS)
    NetworkManager create_network_manager();

    // Create a new messaging manager
    MessagingAPI create_messaging_manager(string peer_id);

    // Create a new privacy manager
    PrivacyAPI create_privacy_manager();

    // Initialize the logger callback
    void init_logger(CoreLogger callback);
};

// Logger callback interface
callback interface CoreLogger {
    void log(string level, string message);
};

// A user's cryptographic identity
dictionary Identity {
    string public_key_hex;
    string private_key_hex;
};

// Result of Diffie-Hellman key exchange
dictionary SharedSecret {
    string secret_hex;
};

// Information about a discovered peer
dictionary PeerInfo {
    string peer_id;
    sequence<string> addresses;
};

// Events from the P2P network
[Enum]
interface NetworkEvent {
    Listening(string address);
    PeerDiscovered(PeerInfo peer);
    PeerConnected(string peer_id);
    PeerDisconnected(string peer_id);
    MessageReceived(string peer_id, sequence<u8> data);
    Error(string message);
};

// Network manager for P2P operations
interface NetworkManager {
    // Get our peer ID
    string get_peer_id();
    
    // Start the P2P node
    [Throws=NetworkError]
    void start();
    
    // Stop the P2P node
    void stop();
    
    // Check if running
    boolean is_running();
    
    // Get connected peers
    sequence<PeerInfo> get_peers();
    
    // Dial a multiaddr
    [Throws=NetworkError]
    void dial(string address);
    
    // Poll for next event (non-blocking, returns null if no event)
    NetworkEvent? poll_event();
    
    // Send a message to a peer
    [Throws=NetworkError]
    void send_message(string peer_id, sequence<u8> data);
};

// Messaging API
interface MessagingAPI {
    // Add a contact
    void add_contact(string peer_id, string name, sequence<u8> identity_key);
    
    // Get prekey bundle as JSON string
    string get_prekey_bundle();
    
    // Initiate session with peer using their bundle (JSON)
    [Throws=NetworkError]
    void initiate_session(string peer_id, string bundle_json);
    
    // Send text message (returns message ID)
    [Throws=NetworkError]
    string send_message(string peer_id, string text);
    
    // Handle incoming data from network
    [Throws=NetworkError]
    void handle_incoming(string from_peer_id, sequence<u8> data);
    
    // Get next outgoing message (returns null if none)
    OutgoingMessage? next_outgoing();
    
    // Get next event (returns null if none)
    MessagingAPIEvent? next_event();

    // List all contacts
    sequence<ContactInfo> list_contacts();

    // Create an onion envelope
    sequence<u8> create_onion_envelope(sequence<u8> packet_bytes);
};

dictionary ContactInfo {
    string peer_id;
    string name;
    boolean session_established;
};

dictionary OutgoingMessage {
    string peer_id;
    sequence<u8> data;
};

[Enum]
interface MessagingAPIEvent {
    MessageReceived(string from_peer_id, string text, string id);
    MessageSent(string to_peer_id, string message_id);
    SessionEstablished(string peer_id);
    DeliveryReceipt(string peer_id, string message_id);
    RelayAnnouncement(string peer_id, string public_key_hex);
    OnionPacketReceived(sequence<u8> data);
    Error(string message);
};



// Network errors
[Error]
enum NetworkError {
    "AlreadyRunning",
    "NotRunning",
    "StartFailed",
    "ConnectionFailed",
    "GenericError",
};

// Privacy API
interface PrivacyAPI {
    void set_onion_enabled(boolean enabled);
    boolean is_onion_enabled();
    void register_relay(string peer_id, string public_key_hex);
    void unregister_relay(string peer_id);
    u64 relay_count();
    boolean can_build_circuit();
    string relay_public_key();
    boolean process_incoming(sequence<u8> packet_bytes);
    PrivacyAPIEvent? next_event();
    OutgoingOnionPacket? wrap_message(sequence<u8> payload, string destination_peer_id);
};

[Enum]
interface PrivacyAPIEvent {
    RelayPacket(string next_peer_id, sequence<u8> packet_bytes, u64 delay_ms);
    PacketDelivered(sequence<u8> payload);
    DeliverPayload(string next_peer_id, sequence<u8> payload);
    CircuitBuilt(u64 circuit_id, u64 hops);
    Error(string message);
};

dictionary OutgoingOnionPacket {
    string entry_peer_id;
    sequence<u8> packet_bytes;
    u64 delay_ms;
};
